// <auto-generated>
//     Generated by the Lambda.Host source generator.
// </auto-generated>

#pragma warning disable CS1998 // Async method lacks 'await' operators and will run synchronously

#nullable enable

{{~ if !is_global_namespace ~}}
namespace {{ class_namespace }};

{{~ end ~}}
{{ accessibility }} {{ if is_partial_class }}partial {{ end }}class {{ service }}{{ if !is_partial_class }} : global::Lambda.Host.LambdaHostedService{{ end }}
{
    {{~ for dependency in injected_dependencies ~}}
    private readonly {{ dependency.type }} {{ dependency.field_name }};
    {{~ end ~}}

    public {{ service }}({{ for dependency in injected_dependencies }}{{ dependency.type }} {{ dependency.parameter_name }}{{ if !for.last }}, {{ end }}{{ end }})
    {
        {{~ for dependency in injected_dependencies ~}}
        this.{{ dependency.field_name }} = {{ dependency.parameter_name }};
        {{~ end ~}}
    }
    
    public override global::System.Threading.Tasks.Task StartAsync(global::System.Threading.CancellationToken cancellationToken)
    {
        if (!this._delegateHolder.IsHandlerSet)
            throw new global::System.InvalidOperationException("Handler is not set");
            
        if (this._delegateHolder.Handler is not {{ delegate_type }} {{~ if delegate_args.size > 0 ~}} <{{ delegate_args | array.join ", " }}> {{~ end }} lambdaHandler)
            throw new global::System.InvalidOperationException("Invalid handler type.");
            
        global::Amazon.Lambda.RuntimeSupport.LambdaBootstrapBuilder
            .Create(
                {{ if is_lambda_async ~}} async {{ end ~}}({{ for lambda_param in lambda_params }}{{ lambda_param.type }} {{ lambda_param.name }}{{ if !for.last }}, {{ end }}{{ end }}) => 
                {
                    {{~ if cancellation_token_details.is_cancellation_token_requested ~}}
                    using var __cancellationTokenSource = _lambdaCancellationTokenSourceFactory.NewCancellationTokenSource({{ cancellation_token_details.lambda_context_parameter_name }});
                    var {{ cancellation_token_details.cancellation_token_var_name }} = __cancellationTokenSource.Token;
                    
                    {{~ end ~}}
                    {{~ if class_fields.size > 0 ~}}
                    using var __scope = global::Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.CreateScope(this._serviceProvider);
                    
                        {{~ for field in class_fields ~}}
                            {{~ if field.keyed_service_key ~}}
                    var {{ field.name }} = global::Microsoft.Extensions.DependencyInjection.ServiceProviderKeyedServiceExtensions.GetRequiredKeyedService<{{ field.type }}>(__scope.ServiceProvider, "{{ field.keyed_service_key }}");
                            {{~ else ~}}
                    var {{ field.name }} = global::Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<{{ field.type }}>(__scope.ServiceProvider);
                            {{~ end ~}}
                        {{~ end ~}}
                    
                    {{~ end ~}}
                    {{ if has_return_value ~}}var __response = {{ end ~}}{{~ if is_lambda_async ~}} await {{ end ~}}lambdaHandler({{ for handler_arg in handler_args }}{{ handler_arg.name }}{{ if !for.last }}, {{ end }}{{ end }});
                    {{~ if has_return_value ~}}
                    
                    return __response;
                    {{~ end ~}}
                }{{ if is_serializer_needed ~}},
                this._lambdaSerializer{{~ end }}
            )
            .Build()
            .RunAsync(cancellationToken);
        
        return global::System.Threading.Tasks.Task.CompletedTask;
    }
}