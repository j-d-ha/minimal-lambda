// <auto-generated>
//     Generated by the Lambda.Host source generator.
// </auto-generated>

#pragma warning disable CS1998 // Async method lacks 'await' operators and will run synchronously

#nullable enable

{{~ if !is_global_namespace ~}}
namespace {{ class_namespace }};

{{~ end ~}}
{{ accessibility }} {{ if is_partial_class }}partial {{ end }}class {{ class_name }}{{ if !is_partial_class }} : global::Lambda.Host.LambdaHostedService{{ end }}
{
    {{ accessibility }} {{ class_name }}(
        global::Microsoft.Extensions.Options.IOptions<global::Lambda.Host.LambdaHostSettings> lambdaHostSettings,
        global::Lambda.Host.DelegateHolder delegateHolder,
        global::System.IServiceProvider serviceProvider,
        global::Lambda.Host.Interfaces.ILambdaCancellationTokenSourceFactory lambdaCancellationTokenSourceFactory
    )
        : base(
            lambdaHostSettings,
            delegateHolder,
            serviceProvider,
            lambdaCancellationTokenSourceFactory
        ) { }
    
    public override global::System.Threading.Tasks.Task StartAsync(global::System.Threading.CancellationToken cancellationToken)
    {
        if (!this.DelegateHolder.IsHandlerSet)
            throw new global::System.InvalidOperationException("Handler is not set");
            
        if (this.DelegateHolder.Handler is not {{ delegate_type }} {{~ if delegate_args.size > 0 ~}} <{{ delegate_args | array.join ", " }}> {{~ end }} lambdaHandler)
            throw new global::System.InvalidOperationException("Invalid handler type.");
            
        global::Amazon.Lambda.RuntimeSupport.LambdaBootstrapBuilder
            .Create(
                {{ if is_lambda_async ~}} async {{ end ~}}({{ for lambda_param in lambda_params }}{{ lambda_param.type }} {{ lambda_param.name }}{{ if !for.last }}, {{ end }}{{ end }}) => 
                {
                    {{~ if cancellation_token_details.is_cancellation_token_requested ~}}
                    using var __cancellationTokenSource = this.LambdaCancellationTokenSourceFactory.NewCancellationTokenSource({{ cancellation_token_details.lambda_context_parameter_name }});
                    var {{ cancellation_token_details.cancellation_token_var_name }} = __cancellationTokenSource.Token;
                    
                    {{~ end ~}}
                    {{~ if handler_dependencies.size > 0 ~}}
                    using var __scope = global::Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.CreateScope(this.ServiceProvider);
                    
                        {{~ for field in handler_dependencies ~}}
                            {{~ if field.keyed_service_key ~}}
                    var {{ field.name }} = global::Microsoft.Extensions.DependencyInjection.ServiceProviderKeyedServiceExtensions.GetRequiredKeyedService<{{ field.type }}>(__scope.ServiceProvider, "{{ field.keyed_service_key }}");
                            {{~ else ~}}
                    var {{ field.name }} = global::Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService<{{ field.type }}>(__scope.ServiceProvider);
                            {{~ end ~}}
                        {{~ end ~}}
                    
                    {{~ end ~}}
                    {{ if has_return_value ~}}var __response = {{ end ~}}{{~ if is_lambda_async ~}} await {{ end ~}}lambdaHandler({{ for handler_arg in handler_args }}{{ handler_arg.name }}{{ if !for.last }}, {{ end }}{{ end }});
                    {{~ if has_return_value ~}}
                    
                    return __response;
                    {{~ end ~}}
                }{{ if is_serializer_needed ~}},
                this.LambdaHostSettings.LambdaSerializer{{~ end }}
            )
            .Build()
            .RunAsync(cancellationToken);
        
        return global::System.Threading.Tasks.Task.CompletedTask;
    }
}