//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#nullable enable

namespace System.Runtime.CompilerServices
{
    using System.CodeDom.Compiler;

    {{ generated_code_attribute.value }}
    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]
    file sealed class InterceptsLocationAttribute : Attribute
    {
        public InterceptsLocationAttribute(int version, string data) { }
    }
}

namespace MinimalLambda.Generated
{
    using System;
    using System.Runtime.CompilerServices;
    using System.Threading;
    using System.Threading.Tasks;
    using Microsoft.Extensions.DependencyInjection;
    using MinimalLambda;
    using MinimalLambda.Builder;

    {{ generated_code_attribute.value }}
    file static class UseMiddlewareExtensions
    {
        {{~ for call in calls ~}}
        {{ call.interceptable_location_attribute }}
        internal static ILambdaInvocationBuilder UseMiddleware{{ for.index }}<T>(
            this ILambdaInvocationBuilder builder,
            params object[] args
        )
            where T : ILambdaMiddleware
        {
            var resolver = new {{ call.class_info.short_name }}Resolver{{ for.index }}(args);

            {{~ if call.class_info.implements_async_disposable ~}}
            builder.Use(next =>
            {
                return async context =>
                {
                    await using var middleware = resolver.Create(context);
                    await middleware.InvokeAsync(context, next);
                };
            });
            {{~ else if call.class_info.implements_disposable  ~}}
            builder.Use(next =>
            {
                return async context =>
                {
                    using var middleware = resolver.Create(context);
                    await middleware.InvokeAsync(context, next);
                };
            });
            {{~ else ~}}
            builder.Use(next =>
            {
                return context =>
                {
                    return resolver.Create(context).InvokeAsync(context, next);
                };
            });
            {{~ end ~}}

            return builder;
        }

        private class {{ call.class_info.short_name }}Resolver{{ for.index }}
        {
            {{~ if call.class_info.parameter_infos.count > 0 && !call.class_info.all_parameters_from_services ~}}
            private const int NotCached = -1;
            private const int FromServices = -2;
            private bool _cacheBuilt = false;
            {{~ end ~}}
            private readonly object[] _args;

            {{~ for parameter in call.class_info.parameter_infos ~}}
            {{~ if !parameter.from_services ~}}
            private int _cache{{ for.index }} = NotCached; // {{ parameter.globally_qualified_type }}
            {{~ end ~}}
            {{~ end ~}}
            {{~ if call.class_info.parameter_infos.count > 0 && !call.class_info.all_parameters_from_services ~}}

            {{~ end ~}}
            internal {{ call.class_info.short_name }}Resolver{{ for.index }}(object[] args) => _args = args;

            internal {{ call.class_info.globally_qualified_name }} Create(ILambdaInvocationContext context)
            {
                {{~ if call.class_info.parameter_infos.count > 0 ~}}
                {{~ if !call.class_info.all_parameters_from_services ~}}
                if (!_cacheBuilt)
                    BuildResolutionCache();

                {{~ end ~}}
                {{~ for parameter in call.class_info.parameter_infos ~}}
                {{~ if parameter.from_services ~}}
                var arg{{ for.index }} = {{ parameter.from_services_assignment }};
                {{~ else ~}}
                var arg{{ for.index }} =
                    _cache{{ for.index }} >= 0
                        ? ({{ parameter.globally_qualified_type }})_args[_cache{{ for.index }}]
                        {{~ if parameter.from_arguments ~}}
                        : throw new InvalidOperationException("Parameter '{{ parameter.name }}' of type '{{ parameter.globally_qualified_type }}' must be provided in args");
                        {{~ else ~}}
                        : {{ parameter.from_services_assignment }};
                        {{~ end ~}}
                {{~ end ~}}

                {{~ end ~}}
                {{~ end ~}}
                return new {{ call.class_info.globally_qualified_name }}({{ for arg in call.class_info.parameter_infos }}arg{{ for.index }}{{ if !for.last }}, {{ end }}{{ end }});
            }
            {{~ if call.class_info.parameter_infos.count > 0 && !call.class_info.all_parameters_from_services ~}}

            private void BuildResolutionCache()
            {
                {{~ for parameter in call.class_info.parameter_infos ~}}
                {{~ if !parameter.from_services ~}}
                _cache{{ for.index }} = FromServices;
                {{~ end ~}}
                {{~ end ~}}

                for (var i = 0; i < _args.Length; i++)
                {
                    var arg = _args[i];
                    if (arg is null)
                        continue;

                    switch (arg)
                    {
                        {{~ for parameter in call.class_info.parameter_infos ~}}
                        {{~ if !parameter.from_services ~}}
                        case {{ parameter.globally_qualified_not_nullable_type }} when _cache{{ for.index }} == FromServices:
                            _cache{{ for.index }} = i;
                            break;
                        {{~ end ~}}
                        {{~ end ~}}
                    }
                }
                _cacheBuilt = true;
            }
            {{~ end ~}}
        }
        {{~ if !for.last ~}}

        {{~ end ~}}
        {{~ end ~}}
    }
}