//HintName: MinimalLambda.UseMiddleware.g.cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#nullable enable

namespace System.Runtime.CompilerServices
{
    using System.CodeDom.Compiler;

    [global::System.CodeDom.Compiler.GeneratedCode("MinimalLambda.SourceGenerators", "REPLACED")]
    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]
    file sealed class InterceptsLocationAttribute : Attribute
    {
        public InterceptsLocationAttribute(int version, string data) { }
    }
}

namespace MinimalLambda.Generated
{
    using System;
    using System.Runtime.CompilerServices;
    using System.Threading;
    using System.Threading.Tasks;
    using Microsoft.Extensions.DependencyInjection;
    using MinimalLambda;
    using MinimalLambda.Builder;

    [global::System.CodeDom.Compiler.GeneratedCode("MinimalLambda.SourceGenerators", "REPLACED")]
    file static class UseMiddlewareExtensions
    {
        [InterceptsLocation(1, "REPLACED")]
        internal static ILambdaInvocationBuilder UseMiddleware0<T>(
            this ILambdaInvocationBuilder builder,
            params object[] args
        )
            where T : ILambdaMiddleware
        {
            var resolver = new MyLambdaMiddlewareResolver0(args);

            builder.Use(next =>
            {
                return context =>
                {
                    return resolver.Create(context).InvokeAsync(context, next);
                };
            });

            return builder;
        }

        private class MyLambdaMiddlewareResolver0
        {
            private const int NotCached = -1;
            private const int FromServices = -2;
            private bool _cacheBuilt = false;
            private readonly object[] _args;

            private int _cache2 = NotCached; // string
            private int _cache3 = NotCached; // global::IMetrics?

            internal MyLambdaMiddlewareResolver0(object[] args) => _args = args;

            internal global::MyLambdaMiddleware Create(ILambdaInvocationContext context)
            {
                if (!_cacheBuilt)
                    BuildResolutionCache();

                var arg0 = context.ServiceProvider.GetRequiredService<global::ILogger>();

                var arg1 = context.ServiceProvider.GetRequiredKeyedService<global::ICache>("cache");

                var arg2 =
                    _cache2 >= 0
                        ? (string)_args[_cache2]
                        : throw new InvalidOperationException("Parameter 'apiKey' of type 'string' must be provided in args");

                var arg3 =
                    _cache3 >= 0
                        ? (global::IMetrics?)_args[_cache3]
                        : context.ServiceProvider.GetService<global::IMetrics?>();

                return new global::MyLambdaMiddleware(arg0, arg1, arg2, arg3);
            }

            private void BuildResolutionCache()
            {
                _cache2 = FromServices;
                _cache3 = FromServices;

                for (var i = 0; i < _args.Length; i++)
                {
                    var arg = _args[i];
                    if (arg is null)
                        continue;

                    switch (arg)
                    {
                        case string when _cache2 == FromServices:
                            _cache2 = i;
                            break;
                        case global::IMetrics when _cache3 == FromServices:
                            _cache3 = i;
                            break;
                    }
                }
                _cacheBuilt = true;
            }
        }
    }
}