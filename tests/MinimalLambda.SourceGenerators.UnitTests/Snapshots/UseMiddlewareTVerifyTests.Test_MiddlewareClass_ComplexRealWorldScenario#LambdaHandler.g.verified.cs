//HintName: LambdaHandler.g.cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#pragma warning disable CS1998 // Async method lacks 'await' operators and will run synchronously

#nullable enable

namespace System.Runtime.CompilerServices
{
    using System.CodeDom.Compiler;

    [GeneratedCode("MinimalLambda.SourceGenerators", "0.0.0")]
    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]
    file sealed class InterceptsLocationAttribute : Attribute
    {
        public InterceptsLocationAttribute(int version, string data)
        {
        }
    }
}

namespace MinimalLambda.Generated
{
    using System;
    using System.CodeDom.Compiler;
    using System.Runtime.CompilerServices;
    using System.Threading;
    using System.Threading.Tasks;
    using Microsoft.Extensions.DependencyInjection;
    using MinimalLambda;
    using MinimalLambda.Builder;

    [GeneratedCode("MinimalLambda.SourceGenerators", "0.0.0")]
    file static class UseMiddlewareExtensions
    {
        [InterceptsLocation(1, "kDxACCQgVpkhkOccrv1uASMBAABJbnB1dEZpbGUuY3M=")]
        internal static ILambdaInvocationBuilder UseMiddleware0<T>(
            this ILambdaInvocationBuilder builder,
            params object[] args
        )
            where T : ILambdaMiddleware
        {
            var resolver = new MyLambdaMiddlewareResolver0(args);
            
            builder.Use(next =>
            {
                return context =>
                {
                    return resolver.Create(context).InvokeAsync(context, next);
                };
            });

            return builder;
        }

        private class MyLambdaMiddlewareResolver0
        {
            private const int NotCached = -1;
            private const int FromServices = -2;
            private bool _cacheBuilt = false;
            private readonly object[] _args;

            private int _cache0 = NotCached; // string
            private int _cache3 = NotCached; // global::IDataService?
            
            internal MyLambdaMiddlewareResolver0(object[] args) => _args = args;

            internal global::MyLambdaMiddleware Create(ILambdaInvocationContext context)
            {
                if (!_cacheBuilt)
                    BuildResolutionCache();

                // ParameterInfo { Type = string, Name = name, Source = Service, IsNullable = False, IsOptional = False}
                var arg0 =
                    _cache0 >= 0
                        ? (string)_args[_cache0]
                        : throw new InvalidOperationException("Parameter 'name' of type 'string' must be provided in args");
                
                // ParameterInfo { Type = global::ILogger, Name = logger, Source = KeyedService, IsNullable = False, IsOptional = False, KeyedServiceKeyInfo { DisplayValue = "primary", Type = string, BaseType = object } }
                var arg1 = context.ServiceProvider.GetRequiredKeyedService<global::ILogger>("primary");
                
                // ParameterInfo { Type = global::IMetrics, Name = metrics, Source = Service, IsNullable = False, IsOptional = False}
                var arg2 = context.ServiceProvider.GetRequiredService<global::IMetrics>();
                
                // ParameterInfo { Type = global::IDataService?, Name = dataService, Source = Service, IsNullable = True, IsOptional = False}
                var arg3 =
                    _cache3 >= 0
                        ? (global::IDataService?)_args[_cache3]
                        : context.ServiceProvider.GetService<global::IDataService?>();
                
                return new global::MyLambdaMiddleware(arg0, arg1, arg2, arg3);
            }
            
            private void BuildResolutionCache()
            {
                _cache0 = FromServices;
                _cache3 = FromServices;

                for (var i = 0; i < _args.Length; i++)
                {
                    var arg = _args[i];
                    if (arg is null)
                        continue;

                    switch (arg)
                    {
                        case string when _cache0 == FromServices:
                            _cache0 = i;
                            break;
                        case global::IDataService when _cache3 == FromServices:
                            _cache3 = i;
                            break;
                    }
                }
                _cacheBuilt = true;
            }
        }
    }

    file static class Utilities
    {
        internal static T Cast<T>(Delegate d, T _) where T : Delegate => (T)d;
    }
}